&emsp;&emsp;在流程中，我们实现了一个简单的双均线策略：TwoSmaStrategy：
```python
# 创建策略类：双均线
class TwoSmaStrategy(bt.Strategy):
    params = (('short', 5), ('long', 10))
    def __init__(self):
        self.order = None #初始化订单
        self.sma_s = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.short)
        self.sma_l = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.long)
    
    # 策略方法
    def next(self):
        if self.order:
            return
        # 检查是否已经买入
        if not self.position:
        # 如果没有买入，并且短期均线 > 长期均线，说明涨势，买入
            if self.sma_s[0] > self.sma_l[0]:
                self.order = self.buy()
        else:
        # 已经买了，并且短期均线 < 长期均线，说明跌势，卖出
            if self.sma_s[0] < self.sma_l[0]:
                self.order = self.sell()
```
&emsp;&emsp;在这个类中，我们首先定义了一个似乎是元组类型的类成员变量params，里面有两个元组类型的元素，每个元组元素里面都有两个元素：字符串和数字，表示长短周期。  
&emsp;&emsp;接下来，定义了__init__()方法，这是我们熟悉的实例初始化的方法。这个方法里面初始化订单，计算了长短周期的均线。这里调用params参数不符合元组类型的方式，这是怎么一回事呢？  
&emsp;&emsp;最后是一个next()方法，这个方法里面是策略逻辑，用于实现买卖。这个next()是对bt.Strategy next()方法的重写。  
&emsp;&emsp;策略实现很简单，除了上述参数调用的问题外，这里还有几个问题：params参数可以在外部更改吗，如何更改；可不可以获取中间的交易信息？  
&emsp;&emsp;我们在__init__()方法中加上打印：
```python
def __init__(self):
        print(TwoSmaStrategy.params)
        print(self.params)
        self.order = None #初始化订单
        self.sma_s = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.short)
        self.sma_l = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.long)
```
&emsp;&emsp;运行策略，有两条打印：  
<class 'backtrader.metabase.AutoInfoClass_LineRoot_LineMultiple_LineSeries_LineIterator_DataAccessor_StrategyBase_Strategy_TwoSmaStrategy'>  
<backtrader.metabase.AutoInfoClass_LineRoot_LineMultiple_LineSeries_LineIterator_DataAccessor_StrategyBase_Strategy_TwoSmaStrategy object at 0x7f212ac9d8d0>  
&emsp;&emsp;第一条打印表示TwoSmaStrategy.params是一个类，第二条打印表示self.params是由第一个打印出来类实例化的对象。这表明params在Backtrader中被处理成类了，short和long也就成了属性。  
&emsp;&emsp;针对修改params参数的问题，首先在__init__()中加入参数值的打印：
```python
def __init__(self):
        print('short={}, long={}'.format(self.params.short, self.params.long))
        self.order = None #初始化订单
        self.sma_s = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.short)
        self.sma_l = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.long)
```
运行后，打印short=5, long=10，和我们设置的一样。那如何修改呢？我们按照修改类参数方式修改：
```python
TwoSmaStrategy.params=(('short', 15), ('long', 20))
```
程序会给我们报错，也就是这样修改时不行的。正确的修改方式是在cerebro加载类时候修改：
```python
cerebro.addstrategy(TwoSmaStrategy, short=10, long=15) 
```
运行后输出：short=10, long=15，完成了参数修改。cerebro.addstrategy()实参名称要和params里字符串一致。当然也可以只设置一个。  
&emsp;&emsp;流程里的代码只有最后评价的输出，没有中间交易的信息。如何获得中间信息？需要重写bt.Strategy的notify_order()和notify_trade()两个方法：
```python
class TwoSmaStrategy(bt.Strategy):
    params = (('short', 5), ('long', 10))
    def __init__(self):
        self.order = None 
        self.sma_s = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.short)
        self.sma_l = bt.indicators.MovingAverageSimple(self.datas[0].lines.close, period=self.params.long)
    
    def next(self):
        if self.order:
            return
        if not self.position:
            if self.sma_s[0] > self.sma_l[0]:
                self.order = self.buy()
        else:
            if self.sma_s[0] < self.sma_l[0]:
                self.order = self.sell()
    
    # 定义信息输出方式            
    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.date(0)
        print('%s, %s' % (dt.isoformat(), txt))
    
    # 定义获取订单变动信息的方法，一般来说，这是一个固定的模板化的方法
    def notify_order(self, order):
        # print("status: ", order.status)
        if order.status in [order.Submitted, order.Accepted]:
            # 订单处于提交或者接受状态时，一般不打印信息
            return
        if order.status == order.Completed:
            # 订单完成
            if order.isbuy():
                # 买入
                self.log(
                    'buy info: price: {}, value: {}, commision: {}'.format(order.executed.price, order.executed.value,
                                                                           order.executed.comm))
            else:
                # 卖出
                self.log(
                    'sell info: price: {}, value: {}, commision: {}'.format(order.executed.price, order.executed.value,
                                                                            order.executed.comm))
        elif order.status == order.Rejected:
            self.log('order is rejected')
        elif order.status == order.Margin:
            self.log('order is margin')
        elif order.status == order.Cancelled:
            self.log('order is cancelled')
        elif order.status == order.Partial:
            self.log('order is partial')

        self.order = None

    # 获取每次交易变动的信息
    def notify_trade(self, trade):
        if not trade.isclosed:
            return
        self.log('Trade Closed: Gross Profit: % .2f, Net Profit: % .2f' % (trade.pnl, trade.pnlcomm))
```
&emsp;&emsp;运行策略，就可以获得每次订单和交易变化的信息。